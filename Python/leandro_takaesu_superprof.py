# -*- coding: utf-8 -*-
"""leandro_takaesu_superprof.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19KQjXsQetnDihUB6qb-hm4jj19IDyg8C
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

dados_cursos = {
    'curso_id': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    'categoria': ['Programação', 'Design', 'Marketing', 'Programação', 'Design', 'Marketing', 'Programação', 'Design', 'Marketing', 'Programação'],
    'duracao_horas': [40, 30, 25, 60, 35, 20, 80, 28, 22, 55],
    'nota_media_alunos': [4.8, 4.5, 4.2, 4.9, 4.7, 4.3, 4.8, 4.6, 4.1, 4.7],
    'numero_alunos': [1200, 800, 1500, 900, 750, 1800, 1100, 650, 1600, 1300]
}
df_cursos = pd.DataFrame(dados_cursos)
print(df_cursos)

"""No papel de gerente:Será que existe mesmo uma relação entre a duração de um curso e a nota média que ele recebe?"

No papel de analista:  
Escolhas

Do exame: (Boxplot, Histplot, Scatterplot, Heatmap) ? Scatterplot
Realização do exame: Escrever o codigo
Apresentação do diagnostico:
"""

df_cursos.plot(kind='scatter', x='duracao_horas', y='nota_media_alunos')
# plt.show()

sns.scatterplot(data=df_cursos, x='duracao_horas', y='nota_media_alunos')
# plt.show()

"""Adicionar uma linha de tendência para ver a relação mais claramente

"""

sns.regplot(x='duracao_horas', y='nota_media_alunos', data=df_cursos, color='red', scatter=False)
# plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Gerando dados de idade simulados para 500 clientes
np.random.seed(123) # Para garantir que os dados sejam sempre os mesmos
idades_clientes = np.random.normal(loc=35, scale=10, size=500).astype(int)

idades_clientes = idades_clientes[(idades_clientes >= 18) & (idades_clientes <= 70)]

df_clientes = pd.DataFrame({'idade': idades_clientes})
print(df_clientes)

"""Qual é o perfil de idade dos nossos clientes? Onde devemos concentrar nosso foco?"

No papel de analista:
Escolhas

Do exame: (Boxplot, Histplot, Scatterplot, Heatmap) ?  Realização do exame: Escrever o codigo Apresentação do diagnostico:
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

sns.boxplot(data=df_clientes, y='idade')

"""Ele mostra
mediana
a faixa de idade dos 50% centrais (28 e 42 anos)
outliers: idades discrepantes

Ele não mostra
A forma de distribuição que são os picos, ou seja, ele mostra a faixa de idade 30-40 anos , mas não diz onde está a maior concentração.

Bimodalidade: Dois grupos principais de clientes (um de 20 anos e outro de 50), o histograma mostraria dois picos claros. O boxplot esconderia completamente essa informação, mostrando apenas uma caixa larga no meio.

Analogia

"Onde está a maior concentração de clientes? Qual o perfil e o pico de idade?"

O Histograma (Eletrocardiograma): mostra ritmo e picos de frequencia
O Boxplot (Medidor de Pressão): resumo estatistico (pressao sistolica media 120 e diastolica 80), não mostra o ritmo cardiaco.

Queremos comparar a distribuição de idade dos clientes que compram 'Eletrônicos' vs. os que compram 'Roupas'. Qual grupo é mais jovem?

Faça o histograma
e o projeto que esta no github

Funções de Janela (Window Functions).

Considerando uma longa série de dados diários, como as vendas de uma loja. Em casos que ocorre muita variação (ruídos).
Objetivo: Conseguir visualizar a tendência real, ignorando as flutuações diárias.

A ideia é calcular uma métrica (como a média) em uma "janela" de dados que desliza sobre sua série de dados. A mais comum é a Média Móvel

 O metodo .rolling() -> cria uma janela deslizante para possibilitar a  agregação.

 Parametro: window -> tamanho da janela.
 Ex.: window=7, janela de 7 periodos.

 Uso: .mean(), .sum(), std().
"""

# # Create a sample time series dataset
# data = {'vendas': [10, 12, 15, 11, 13, 16, 14, 18, 17, 20, 19, 22, 21, 25, 24, 28, 27, 30, 29, 33]}
# df_vendas = pd.DataFrame(data)

# # Calculate a 3-period moving average
# df_vendas['media_movel_3'] = df_vendas['vendas'].rolling(window=3).mean()

# # Calculate a 5-period moving average
# df_vendas['media_movel_5'] = df_vendas['vendas'].rolling(window=5).mean()

# print(df_vendas)

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

np.random.seed(0)
datas = pd.date_range(start='2025-01-01', periods=90, freq='D')
vendas_base = np.linspace(100, 150, 90) # Uma tendência de crescimento suave
ruido = np.random.randint(-30, 30, 90)
vendas_diarias = vendas_base + ruido


### Linha 1: `np.random.seed(0)`

# O que faz? "Trava" a aleatoriedade.
# Explicação Detalhada: Computadores não geram números verdadeiramente aleatórios, mas sim "pseudoaleatórios", que são sequências de números que parecem aleatórias, mas são geradas por um algoritmo. Se você começar o algoritmo com o mesmo número inicial (a "semente" ou `seed`), ele sempre produzirá a mesma sequência de números "aleatórios".
# Analogia: Pense nisso como o "seed" de um mapa no jogo Minecraft. Se você e seu amigo usarem o mesmo seed, o mundo gerado será exatamente o mesmo. Usar `np.random.seed(0)` garante que toda vez que rodarmos este script, os dados de "ruído" gerados na linha 4 sejam idênticos, tornando nosso exemplo reprodutível.

### Linha 2: `datas = pd.date_range(start='2025-01-01', periods=90, freq='D')`

# O que faz? Cria uma sequência de 90 dias consecutivos.
# Explicação Detalhada: Usamos a função `date_range` do pandas, que é especialista em criar sequências de datas.
#     * `start='2025-01-01'`: Define o ponto de partida.
#     * `periods=90`: Define quantos itens queremos na nossa sequência (90 datas).
#     * `freq='D'`: Define a frequência. `'D'` significa "Day" (dia).
# Resultado: A variável `datas` agora contém uma lista de 90 datas, começando em 1º de Janeiro de 2025 e terminando 90 dias depois. Este será o nosso eixo do tempo.


### Linha 3: `vendas_base = np.linspace(100, 150, 90)`

# O que faz? Cria a nossa tendência de crescimento suave e perfeita.
# Explicação Detalhada: `np.linspace` (espaço linear) é uma função do NumPy que cria números igualmente espaçados entre um ponto inicial e um final.
#     * `100`: O valor inicial.
#     * `150`: O valor final.
#     * `90`: Quantos "passos" queremos dar entre 100 e 150.
# Analogia: Imagine que você quer desenhar uma rampa reta que começa na altura 100 e termina na altura 150, e você precisa marcar 90 pontos igualmente espaçados ao longo dessa rampa. É exatamente isso que o `linspace` faz.
# Resultado: A variável `vendas_base` contém 90 números que crescem de forma perfeitamente linear de 100 a 150. Esta é a nossa "estrada pavimentada" da analogia anterior.


### Linha 4: `ruido = np.random.randint(-30, 30, 90)`

# O que faz? Cria as flutuações aleatórias do dia a dia.
# Explicação Detalhada: `np.random.randint` gera números inteiros aleatórios.
#     * `-30`: O menor número possível.
#     * `30`: O maior número possível (o limite superior é exclusivo, então na verdade vai até 29).
#     * `90`: Quantos números aleatórios queremos gerar.
# Analogia: Estes são os "buracos e solavancos" que vamos adicionar à nossa estrada perfeitamente pavimentada para que ela pareça real.
# Resultado: A variável `ruido` contém 90 números inteiros aleatórios, positivos e negativos, entre -30 e +29.


### Linha 5: `vendas_diarias = vendas_base + ruido`

# O que faz? Combina a tendência suave com a variação aleatória.
# Explicação Detalhada: Aqui, simplesmente somamos os dois arrays que criamos. O NumPy soma os elementos posição por posição: o primeiro elemento de `vendas_base` com o primeiro de `ruido`, o segundo com o segundo, e assim por diante.
# Resultado Final: A variável `vendas_diarias` contém nossos 90 pontos de dados finais. Eles têm uma tendência geral de crescimento (graças ao `vendas_base`), mas também variam para cima e para baixo a cada dia de forma imprevisível (graças ao `ruido`), simulando um comportamento de vendas muito mais realista.

df_vendas = pd.DataFrame({'Vendas': vendas_diarias}, index=datas)
print(df_vendas)

df_vendas['Media_Movel_7D'] = df_vendas['Vendas'].rolling(window=7).mean()
df_vendas['Media_Movel_30D'] = df_vendas['Vendas'].rolling(window=30).mean()

print("DataFrame com as médias móveis (primeiras 10 linhas):")
print(df_vendas.head(10))

# df_vendas.plot(y=['Vendas', 'Media_Movel_7D', 'Media_Movel_30D'])

df_vendas.plot(
    figsize=(14, 7),
    title='Vendas Diárias vs. Médias Móveis',
    style=['-', '--', ':'] # Estilos de linha diferentes para cada coluna
)

plt.legend(['Vendas Diárias (com ruído)', 'Média Móvel de 7 Dias', 'Média Móvel de 30 Dias'])
plt.ylabel('Valor da Venda')
plt.grid(True)
plt.show()
# plt.show()